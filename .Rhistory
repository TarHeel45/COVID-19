# Run the application
shinyApp(ui = ui, server = server)
# Define server logic
server <- function(input, output, session) {
observe({
LocationChoices <- if (input$DisplayRegions == "continent") { listContinents
} else if (input$DisplayRegions == "sub_region") { listSubRegions
} else if (input$DisplayRegions == "Country") { listCountries
}
updatePickerInput(session, 'Locations', choices = LocationChoices)
})
output$CumulativePlot <- renderPlotly({
browser()
dfTmp <- dfFull[dfFull[[input$DisplayRegions]] %in% input$Locations, ] %>%
group_by((!!sym(input$DisplayRegions)), Date) %>%
summarise(Value = sum((!!sym(input$Outcome)), na.rm=T)) %>%
filter(Date >= input$DateRange[1] & Date <= input$DateRange[2])
PlotText = CreatePlotText(input$DisplayRegions, input$Outcome, input$PlotType, input$ScaleType, F)
eval(parse(text = PlotText))
})
output$LaggedCumulativePlot <- renderPlotly({
dfTmp <- LagMetricByLocation(location = input$DisplayRegions, metric = input$Outcome, minimum = 100)
dfTmp <- dfTmp[dfTmp[[input$DisplayRegions]] %in% input$Locations, ]
PlotText = CreatePlotText(input$DisplayRegions, input$Outcome, input$PlotType, input$ScaleType, T)
eval(parse(text = PlotText))
})
}
# Run the application
shinyApp(ui = ui, server = server)
input$Locations
# Define server logic
server <- function(input, output, session) {
observe({
LocationChoices <- if (input$DisplayRegions == "continent") { listContinents
} else if (input$DisplayRegions == "sub_region") { listSubRegions
} else if (input$DisplayRegions == "Country") { listCountries
}
updatePickerInput(session, 'Locations', choices = LocationChoices)
})
output$CumulativePlot <- renderPlotly({
if (is.null(input$Locations)) { return(NULL)}
dfTmp <- dfFull[dfFull[[input$DisplayRegions]] %in% input$Locations, ] %>%
group_by((!!sym(input$DisplayRegions)), Date) %>%
summarise(Value = sum((!!sym(input$Outcome)), na.rm=T)) %>%
filter(Date >= input$DateRange[1] & Date <= input$DateRange[2])
PlotText = CreatePlotText(input$DisplayRegions, input$Outcome, input$PlotType, input$ScaleType, F)
eval(parse(text = PlotText))
})
output$LaggedCumulativePlot <- renderPlotly({
if (is.null(input$Locations)) { return(NULL)}
dfTmp <- LagMetricByLocation(location = input$DisplayRegions, metric = input$Outcome, minimum = 100)
dfTmp <- dfTmp[dfTmp[[input$DisplayRegions]] %in% input$Locations, ]
PlotText = CreatePlotText(input$DisplayRegions, input$Outcome, input$PlotType, input$ScaleType, T)
eval(parse(text = PlotText))
})
}
# Run the application
shinyApp(ui = ui, server = server)
# Define UI for application
ui <- fluidPage(
# Application title
titlePanel("COVID-19 Dashboard"),
tabsetPanel(type = "tabs",
tabPanel("Main",
sidebarLayout(
sidebarPanel(
width = 3,
dateRangeInput("DateRange", "Date Range:", start = min(dfFull$Date), end = max(dfFull$Date)),
selectizeInput("DisplayRegions", "Select Regions to Display:",
choices = c("Continents" = "continent",
"Sub-Regions" = "sub_region",
"Countries" = "Country"),
selected = c("continent")),
pickerInput("Locations", "Locations", choices = NULL,
options = list(`actions-box` = T, `live-search` = T), multiple = T),
radioButtons("Outcome", "Outcome:",
choices = c("Confirmed Cases" = "Confirmed",
"Deaths" = "Deaths",
"Recoveries" = "Recovered")),
div(tabsetPanel(id = "InputTabsetPanel",
tabPanel("Plot Options",
radioButtons("PlotType", "Plot Type:", choices = c("Line", "Bar")),
radioButtons("ScaleType", "Y-Axis Scale:", choices = c("Linear", "Log-10")))
))
),
mainPanel(
tabsetPanel(type = "tabs",
tabPanel("Cumulative",
plotlyOutput("CumulativePlot", width = "100%")),
tabPanel("Cumulative (Lagged)",
numericInput("LaggedDaysToShow", "Number of Days:", value = as.numeric(max(dfFull$Date) - min(dfFull$Date))),
plotlyOutput("LaggedCumulativePlot", width = "100%"))
)
)
)
)
)
)
# Define server logic
server <- function(input, output, session) {
observe({
LocationChoices <- if (input$DisplayRegions == "continent") { listContinents
} else if (input$DisplayRegions == "sub_region") { listSubRegions
} else if (input$DisplayRegions == "Country") { listCountries
}
updatePickerInput(session, 'Locations', choices = LocationChoices)
})
output$CumulativePlot <- renderPlotly({
if (is.null(input$Locations)) { return(NULL)}
dfTmp <- dfFull[dfFull[[input$DisplayRegions]] %in% input$Locations, ] %>%
group_by((!!sym(input$DisplayRegions)), Date) %>%
summarise(Value = sum((!!sym(input$Outcome)), na.rm=T)) %>%
filter(Date >= input$DateRange[1] & Date <= input$DateRange[2])
PlotText = CreatePlotText(input$DisplayRegions, input$Outcome, input$PlotType, input$ScaleType, F)
eval(parse(text = PlotText))
})
output$LaggedCumulativePlot <- renderPlotly({
if (is.null(input$Locations)) { return(NULL)}
dfTmp <- LagMetricByLocation(location = input$DisplayRegions, metric = input$Outcome, minimum = 100)
dfTmp <- dfTmp[dfTmp[[input$DisplayRegions]] %in% input$Locations, ]
PlotText = CreatePlotText(input$DisplayRegions, input$Outcome, input$PlotType, input$ScaleType, T)
eval(parse(text = PlotText))
})
}
# Run the application
shinyApp(ui = ui, server = server)
dfFull
?lag
dfFull %>% group_by(Province, Country, Date) %>%
mutate(NewCases = Confirmed - lag(Confirmed))
View(dfFull %>% group_by(Province, Country, Date) %>%
mutate(NewCases = Confirmed - lag(Confirmed)))
View(dfFull %>% group_by(Province, Country, Date) %>%
mutate(NewCases = Confirmed - lag(Confirmed, 1)))
lead(1:10, 1)
dfFull
View(dfFull %>% group_by(Province, Country, Date) %>%
mutate(NewCases = Confirmed - lag(Confirmed, 1)))
View(dfFull %>% group_by(Province, Country, Date) %>%
mutate(NewCases = Confirmed - dplyr::lag(Confirmed, 1)))
View(dfFull %>% group_by(Province, Country, Date) %>%
mutate(LaggedCases = dplyr::lag(Confirmed, 1)))
?arrange
View(dfFull %>% group_by(Province, Country, Date) %>%
arrange(Province, Country, Date) %>%
mutate(LaggedCases = dplyr::lag(Confirmed, 1)))
dfFull %>% mutate(LaggedCases = dplyr::lag(Confirmed, 1))
View(dfFull %>% mutate(LaggedCases = dplyr::lag(Confirmed, 1)))
View(dfFull %>% arrange(Province, Country, Date) %>%
group_by(Province, Country) %>%
mutate(LaggedCases = dplyr::lag(Confirmed, 1)))
dfFull <- dfFull %>% arrange(Province, Country, Date) %>%
group_by(Province, Country) %>%
mutate(LaggedCases = dplyr::lag(Confirmed, 1),
LaggedDeaths = dplyr::lag(Deaths, 1),
LaggedRecoveries = dplyr::lag(Recovered, 1)
)
View(dfFull)
4 - NA
?lag
dfConfirmed <- read.csv(file = "csse_covid_19_data/csse_covid_19_time_series/time_series_19-covid-Confirmed.csv")
dfDeaths <- read.csv(file = "csse_covid_19_data/csse_covid_19_time_series/time_series_19-covid-Deaths.csv")
dfRecovered <- read.csv(file = "csse_covid_19_data/csse_covid_19_time_series/time_series_19-covid-Recovered.csv")
head(dfDeaths)
cleanDF <- function(df, valueColName) {
df$Province.State <- as.character(df$Province.State)
df$Country.Region <- as.character(df$Country.Region)
df$Province.State[df$Province.State == ""] <- df$Country.Region[df$Province.State == ""]
df <- df %>% mutate(keyCol = unite(df[, 1:4], col = "key", sep = ";")$key)
df <- df[, -c(1:4)]
df <- df[, c(ncol(df), 2:ncol(df)-1)]
df <- gather(df, "date", valueCol, -keyCol)
df$date <- as.Date(str_replace_all(df$date, "X", ""), format = "%m.%d.%y")
colnames(df)[colnames(df) == "valueCol"] <- valueColName
colnames(df)[colnames(df) == "date"] <- "Date"
df %>% separate(col = 1, into = c("Province", "Country", "Latitude", "Longitude"), sep = ";")
}
cleanDF <- function(df, valueColName) {
df$Province.State <- as.character(df$Province.State)
df$Country.Region <- as.character(df$Country.Region)
df$Province.State[df$Province.State == ""] <- df$Country.Region[df$Province.State == ""]
df <- df %>% mutate(keyCol = unite(df[, 1:4], col = "key", sep = ";")$key)
df <- df[, -c(1:4)]
df <- df[, c(ncol(df), 2:ncol(df)-1)]
df <- gather(df, "date", valueCol, -keyCol)
df$date <- as.Date(str_replace_all(df$date, "X", ""), format = "%m.%d.%y")
colnames(df)[colnames(df) == "valueCol"] <- valueColName
colnames(df)[colnames(df) == "date"] <- "Date"
df %>% separate(col = 1, into = c("Province", "Country", "Latitude", "Longitude"), sep = ";")
}
dfConfirmed.Clean <- cleanDF(dfConfirmed, "Confirmed")
dfDeaths.Clean <- cleanDF(dfDeaths, "Deaths")
dfRecovered.Clean <- cleanDF(dfRecovered, "Recovered")
dfFull <- full_join(dfConfirmed.Clean, dfDeaths.Clean, by = c("Province", "Country", "Latitude", "Longitude", "Date"))
dfFull <- full_join(dfFull, dfRecovered.Clean, by = c("Province", "Country", "Latitude", "Longitude", "Date"))
dfCountryContinentMapping <- read.csv(file = "COVID-19/CountryContinentCrosswalk.csv")
dfFull <- left_join(dfFull, dfCountryContinentMapping[, c("Country", "continent", "sub_region")], by = "Country")
dfFull$continent <- as.character(dfFull$continent)
dfFull$sub_region <- as.character(dfFull$sub_region)
##### Lists of locations (Continent, Sub-Region, Country) #####
dfTmp <- unique(dfFull[, c("Country", "continent", "sub_region")])
dfTmp$continent_sub_region <- paste0(dfTmp$continent, " - ", dfTmp$sub_region)
dfTmp <- unique(dfTmp[, c("continent_sub_region", "Country")])
listCountries <- split(dfTmp, dfTmp$continent_sub_region, drop = T)
for (i in seq_along(listCountries)) {
listCountries[[i]]<- listCountries[[i]]$Country
}
dfTmp <- unique(dfFull[, c("continent", "sub_region")])
listSubRegions <- split(dfTmp, dfTmp$continent, drop = T)
for (i in seq_along(listSubRegions)) {
listSubRegions[[i]] <- listSubRegions[[i]]$sub_region
}
listContinents <- list(unique(dfFull$continent))
names(listContinents) <- "Continents"
dfFull <- dfFull %>% arrange(Province, Country, Date) %>%
group_by(Province, Country) %>%
mutate(LaggedCases = dplyr::lag(Confirmed, 1, default = 0),
LaggedDeaths = dplyr::lag(Deaths, 1, default = 0),
LaggedRecoveries = dplyr::lag(Recovered, 1, default = 0)
)
dfFull <- dfFull %>% mutate(NewCases = Confirmed - LaggedCases,
NewDeaths = Deaths - LaggedDeaths,
NewRecoveries = Recovered - LaggedRecoveries
)
dfFull
View(dfFull)
dfFull <- dfFull %>% mutate(NewCases = Confirmed - LaggedCases,
NewDeaths = Deaths - LaggedDeaths,
NewRecoveries = Recovered - LaggedRecoveries
) %>% select(-c(LaggedCases, LaggedDeaths, LaggedRecoveries))
View(dfFull)
save(dfFull,
dfConfirmed.Clean,
dfDeaths.Clean,
dfRecovered.Clean,
listCountries,
listSubRegions,
listContinents,
file = "data.RData")
CreatePlotText("Country", "Confirmed", "Line", "Linear", F)
str(dfFull)
##### Functions #####
LagOutcomeByLocation <- function(location, metric, minimum = 100) {
dfCaseThreshold <- dfFull %>% group_by((!!sym(location)), Date) %>%
summarise(Value = sum((!!sym(metric)), na.rm=T)) %>%
filter(Value >= minimum) %>%
slice(1) %>%
select((!!sym(location)), Date)
dfTmp <- dfFull %>% group_by((!!sym(location)), Date) %>%
summarise(Value = sum((!!sym(metric)), na.rm = T))
left_join(dfTmp, dfCaseThreshold, by = location, suffix = c("", ".y")) %>%
group_by((!!sym(location)), Date) %>%
filter(Date >= Date.y) %>%
select(-Date.y) %>%
ungroup() %>%
group_by((!!sym(location))) %>%
mutate(TSE = Date - dfCaseThreshold$Date[match((!!sym(location)), dfCaseThreshold[[location]])])
}
CreatePlotText <- function(Region, Outcome, PlotType, ScaleType, LaggedPlot, NewPlot) {
textPlot = "ggplotly(ggplot()"
if (PlotType == "Line") { textPlot = paste(textPlot, "+ geom_line(data = dfTmp, mapping = aes(x =", ifelse(Lagged, "TSE,", "Date,"), "y = Value, color = ", Region, "), size = 1) + theme_minimal()")
} else if (PlotType == "Bar") { textPlot = paste(textPlot, "+ geom_bar(data = dfTmp, mapping = aes(x =", ifelse(Lagged, "TSE,", "Date,"), "y = Value ,fill = ", Region, "), stat = 'Identity', position = \"dodge\") + theme_minimal()")
}
if (LaggedPlot) {
if (Outcome == "Confirmed") {textPlot = paste(textPlot, "+ labs(title = \"Cumulative Confirmed Cases since 100th Confirmed Case\", x = \"Days Since 100th Confirmed Case\", y = \"Confirmed Cases\")")
} else if (Outcome == "Deaths") {textPlot = paste(textPlot, "+ labs(title = \"Cumulative Confirmed Deaths since 100th Confirmed Death\", x = \"Days Since 100th Confirmed Death\", y = \"Confirmed Deaths\")")
} else if (Outcome == "Recovered") { textPlot = paste(textPlot, "+ labs(title = \"Cumulative Confirmed Recoveries since 100th Recovery\", x = \"Days since 100th Recovery\", y = \"Confirmed Recoveries\")")
}
} else {
if (Outcome == "Confirmed") {textPlot = paste(textPlot, "+ labs(title = \"Cumulative Confirmed Cases\", x = \"Date\", y = \"Confirmed Cases\")")
} else if (Outcome == "Deaths") {textPlot = paste(textPlot, "+ labs(title = \"Cumulative Confirmed Deaths\", x = \"Date\", y = \"Confirmed Deaths\")")
} else if (Outcome == "Recovered") { textPlot = paste(textPlot, "+ labs(title = \"Cumulative Confirmed Recoveries\", x = \"Date\", y = \"Confirmed Recoveries\")")
}
}
if (ScaleType == "Linear") {textPlot = paste(textPlot, "+ scale_y_continuous(labels = comma)")
} else if (ScaleType == "Log-10") {textPlot = paste(textPlot, "+ scale_y_continuous(labels = comma, trans = 'log10')")
}
if (LaggedPlot) {textPlot = paste(textPlot, "+ xlim(0, input$LaggedDaysToShow)")
}
if (NewPlot) {textPlot = str_replace_all(textPlot, "Cumulative", "Daily New")}
textPlot = paste0(textPlot, ")")
textPlot
}
# Define UI for application
ui <- fluidPage(
# Application title
titlePanel("COVID-19 Dashboard"),
tabsetPanel(type = "tabs",
tabPanel("Main",
sidebarLayout(
sidebarPanel(
width = 3,
dateRangeInput("DateRange", "Date Range:", start = min(dfFull$Date), end = max(dfFull$Date)),
selectizeInput("DisplayRegions", "Select Regions to Display:",
choices = c("Continents" = "continent",
"Sub-Regions" = "sub_region",
"Countries" = "Country"),
selected = c("continent")),
pickerInput("Locations", "Locations", choices = NULL,
options = list(`actions-box` = T, `live-search` = T), multiple = T),
radioButtons("Outcome", "Outcome:",
choices = c("Confirmed Cases" = "Confirmed",
"Deaths" = "Deaths",
"Recoveries" = "Recovered")),
div(tabsetPanel(id = "InputTabsetPanel",
tabPanel("Plot Options",
radioButtons("PlotType", "Plot Type:", choices = c("Line", "Bar")),
radioButtons("ScaleType", "Y-Axis Scale:", choices = c("Linear", "Log-10")))
))
),
mainPanel(
tabsetPanel(type = "tabs",
tabPanel("Cumulative",
plotlyOutput("CumulativePlot", width = "100%")),
tabPanel("Cumulative (Lagged)",
numericInput("LaggedDaysToShow", "Number of Days:", value = as.numeric(max(dfFull$Date) - min(dfFull$Date))),
plotlyOutput("LaggedCumulativePlot", width = "100%")),
tabPanel("New Outcomes",
plotlyOutput("NewPlot", width = "100%"))
)
)
)
)
)
)
# Define server logic
server <- function(input, output, session) {
observe({
LocationChoices <- if (input$DisplayRegions == "continent") { listContinents
} else if (input$DisplayRegions == "sub_region") { listSubRegions
} else if (input$DisplayRegions == "Country") { listCountries
}
updatePickerInput(session, 'Locations', choices = LocationChoices)
})
output$CumulativePlot <- renderPlotly({
if (is.null(input$Locations)) { return(NULL)}
dfTmp <- dfFull[dfFull[[input$DisplayRegions]] %in% input$Locations, ] %>%
group_by((!!sym(input$DisplayRegions)), Date) %>%
summarise(Value = sum((!!sym(input$Outcome)), na.rm=T)) %>%
filter(Date >= input$DateRange[1] & Date <= input$DateRange[2])
PlotText = CreatePlotText(input$DisplayRegions, input$Outcome, input$PlotType, input$ScaleType, F)
eval(parse(text = PlotText))
})
output$LaggedCumulativePlot <- renderPlotly({
if (is.null(input$Locations)) { return(NULL)}
dfTmp <- LagMetricByLocation(location = input$DisplayRegions, metric = input$Outcome, minimum = 100)
dfTmp <- dfTmp[dfTmp[[input$DisplayRegions]] %in% input$Locations, ]
PlotText = CreatePlotText(input$DisplayRegions, input$Outcome, input$PlotType, input$ScaleType, T)
eval(parse(text = PlotText))
})
output$NewPlot <- renderPlotly({
if (is.null(input$Locations)) { return(NULL)}
if (input$Outcome == "Confirmed") { valCol = "NewCases"
} else if (input$Outcome == "Deaths") { valCol = "NewDeaths"
} else if (input$Outcome == "Recovered") { valCol = "NewRecoveries"}
dfTmp <- dfFull[dfFull[[input$DisplayRegions]] %in% input$Locations, ] %>%
group_by((!!sym(input$DisplayRegions)), Date) %>%
summarise(Value = sum((!!sym(valCol)), na.rm=T)) %>%
filter(Date >= input$DateRange[1] & Date <= input$DateRange[2])
PlotText = CreatePlotText
})
}
# Run the application
shinyApp(ui = ui, server = server)
# Define server logic
server <- function(input, output, session) {
observe({
LocationChoices <- if (input$DisplayRegions == "continent") { listContinents
} else if (input$DisplayRegions == "sub_region") { listSubRegions
} else if (input$DisplayRegions == "Country") { listCountries
}
updatePickerInput(session, 'Locations', choices = LocationChoices)
})
output$CumulativePlot <- renderPlotly({
if (is.null(input$Locations)) { return(NULL)}
dfTmp <- dfFull[dfFull[[input$DisplayRegions]] %in% input$Locations, ] %>%
group_by((!!sym(input$DisplayRegions)), Date) %>%
summarise(Value = sum((!!sym(input$Outcome)), na.rm=T)) %>%
filter(Date >= input$DateRange[1] & Date <= input$DateRange[2])
PlotText = CreatePlotText(input$DisplayRegions, input$Outcome, input$PlotType, input$ScaleType, F)
eval(parse(text = PlotText))
})
output$LaggedCumulativePlot <- renderPlotly({
if (is.null(input$Locations)) { return(NULL)}
dfTmp <- LagMetricByLocation(location = input$DisplayRegions, metric = input$Outcome, minimum = 100)
dfTmp <- dfTmp[dfTmp[[input$DisplayRegions]] %in% input$Locations, ]
PlotText = CreatePlotText(input$DisplayRegions, input$Outcome, input$PlotType, input$ScaleType, T)
eval(parse(text = PlotText))
})
output$NewPlot <- renderPlotly({
if (is.null(input$Locations)) { return(NULL)}
if (input$Outcome == "Confirmed") { valCol = "NewCases"
} else if (input$Outcome == "Deaths") { valCol = "NewDeaths"
} else if (input$Outcome == "Recovered") { valCol = "NewRecoveries"}
dfTmp <- dfFull[dfFull[[input$DisplayRegions]] %in% input$Locations, ] %>%
group_by((!!sym(input$DisplayRegions)), Date) %>%
summarise(Value = sum((!!sym(valCol)), na.rm=T)) %>%
filter(Date >= input$DateRange[1] & Date <= input$DateRange[2])
PlotText = CreatePlotText(input$DisplayRegions, input$Outcome, input$PlotType, input$ScaleType, F, T)
eval(parse(text = PlotText))
})
}
# Run the application
shinyApp(ui = ui, server = server)
CreatePlotText <- function(Region, Outcome, PlotType, ScaleType, LaggedPlot, NewPlot) {
textPlot = "ggplotly(ggplot()"
if (PlotType == "Line") { textPlot = paste(textPlot, "+ geom_line(data = dfTmp, mapping = aes(x =", ifelse(LaggedPlot, "TSE,", "Date,"), "y = Value, color = ", Region, "), size = 1) + theme_minimal()")
} else if (PlotType == "Bar") { textPlot = paste(textPlot, "+ geom_bar(data = dfTmp, mapping = aes(x =", ifelse(LaggedPlot, "TSE,", "Date,"), "y = Value ,fill = ", Region, "), stat = 'Identity', position = \"dodge\") + theme_minimal()")
}
if (LaggedPlot) {
if (Outcome == "Confirmed") {textPlot = paste(textPlot, "+ labs(title = \"Cumulative Confirmed Cases since 100th Confirmed Case\", x = \"Days Since 100th Confirmed Case\", y = \"Confirmed Cases\")")
} else if (Outcome == "Deaths") {textPlot = paste(textPlot, "+ labs(title = \"Cumulative Confirmed Deaths since 100th Confirmed Death\", x = \"Days Since 100th Confirmed Death\", y = \"Confirmed Deaths\")")
} else if (Outcome == "Recovered") { textPlot = paste(textPlot, "+ labs(title = \"Cumulative Confirmed Recoveries since 100th Recovery\", x = \"Days since 100th Recovery\", y = \"Confirmed Recoveries\")")
}
} else {
if (Outcome == "Confirmed") {textPlot = paste(textPlot, "+ labs(title = \"Cumulative Confirmed Cases\", x = \"Date\", y = \"Confirmed Cases\")")
} else if (Outcome == "Deaths") {textPlot = paste(textPlot, "+ labs(title = \"Cumulative Confirmed Deaths\", x = \"Date\", y = \"Confirmed Deaths\")")
} else if (Outcome == "Recovered") { textPlot = paste(textPlot, "+ labs(title = \"Cumulative Confirmed Recoveries\", x = \"Date\", y = \"Confirmed Recoveries\")")
}
}
if (ScaleType == "Linear") {textPlot = paste(textPlot, "+ scale_y_continuous(labels = comma)")
} else if (ScaleType == "Log-10") {textPlot = paste(textPlot, "+ scale_y_continuous(labels = comma, trans = 'log10')")
}
if (LaggedPlot) {textPlot = paste(textPlot, "+ xlim(0, input$LaggedDaysToShow)")
}
if (NewPlot) {textPlot = str_replace_all(textPlot, "Cumulative", "Daily New")}
textPlot = paste0(textPlot, ")")
textPlot
}
# Define UI for application
ui <- fluidPage(
# Application title
titlePanel("COVID-19 Dashboard"),
tabsetPanel(type = "tabs",
tabPanel("Main",
sidebarLayout(
sidebarPanel(
width = 3,
dateRangeInput("DateRange", "Date Range:", start = min(dfFull$Date), end = max(dfFull$Date)),
selectizeInput("DisplayRegions", "Select Regions to Display:",
choices = c("Continents" = "continent",
"Sub-Regions" = "sub_region",
"Countries" = "Country"),
selected = c("continent")),
pickerInput("Locations", "Locations", choices = NULL,
options = list(`actions-box` = T, `live-search` = T), multiple = T),
radioButtons("Outcome", "Outcome:",
choices = c("Confirmed Cases" = "Confirmed",
"Deaths" = "Deaths",
"Recoveries" = "Recovered")),
div(tabsetPanel(id = "InputTabsetPanel",
tabPanel("Plot Options",
radioButtons("PlotType", "Plot Type:", choices = c("Line", "Bar")),
radioButtons("ScaleType", "Y-Axis Scale:", choices = c("Linear", "Log-10")))
))
),
mainPanel(
tabsetPanel(type = "tabs",
tabPanel("Cumulative",
plotlyOutput("CumulativePlot", width = "100%")),
tabPanel("Cumulative (Lagged)",
numericInput("LaggedDaysToShow", "Number of Days:", value = as.numeric(max(dfFull$Date) - min(dfFull$Date))),
plotlyOutput("LaggedCumulativePlot", width = "100%")),
tabPanel("New Outcomes",
plotlyOutput("NewPlot", width = "100%"))
)
)
)
)
)
)
# Define server logic
server <- function(input, output, session) {
observe({
LocationChoices <- if (input$DisplayRegions == "continent") { listContinents
} else if (input$DisplayRegions == "sub_region") { listSubRegions
} else if (input$DisplayRegions == "Country") { listCountries
}
updatePickerInput(session, 'Locations', choices = LocationChoices)
})
output$CumulativePlot <- renderPlotly({
if (is.null(input$Locations)) { return(NULL)}
dfTmp <- dfFull[dfFull[[input$DisplayRegions]] %in% input$Locations, ] %>%
group_by((!!sym(input$DisplayRegions)), Date) %>%
summarise(Value = sum((!!sym(input$Outcome)), na.rm=T)) %>%
filter(Date >= input$DateRange[1] & Date <= input$DateRange[2])
PlotText = CreatePlotText(input$DisplayRegions, input$Outcome, input$PlotType, input$ScaleType, F)
eval(parse(text = PlotText))
})
output$LaggedCumulativePlot <- renderPlotly({
if (is.null(input$Locations)) { return(NULL)}
dfTmp <- LagMetricByLocation(location = input$DisplayRegions, metric = input$Outcome, minimum = 100)
dfTmp <- dfTmp[dfTmp[[input$DisplayRegions]] %in% input$Locations, ]
PlotText = CreatePlotText(input$DisplayRegions, input$Outcome, input$PlotType, input$ScaleType, T)
eval(parse(text = PlotText))
})
output$NewPlot <- renderPlotly({
if (is.null(input$Locations)) { return(NULL)}
if (input$Outcome == "Confirmed") { valCol = "NewCases"
} else if (input$Outcome == "Deaths") { valCol = "NewDeaths"
} else if (input$Outcome == "Recovered") { valCol = "NewRecoveries"}
dfTmp <- dfFull[dfFull[[input$DisplayRegions]] %in% input$Locations, ] %>%
group_by((!!sym(input$DisplayRegions)), Date) %>%
summarise(Value = sum((!!sym(valCol)), na.rm=T)) %>%
filter(Date >= input$DateRange[1] & Date <= input$DateRange[2])
PlotText = CreatePlotText(input$DisplayRegions, input$Outcome, input$PlotType, input$ScaleType, F, T)
eval(parse(text = PlotText))
})
}
# Run the application
shinyApp(ui = ui, server = server)
dfFull
